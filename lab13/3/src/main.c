/**
 * @mainpage
 * # Загальне завдання
 * 1. **Вирахувати** для тексту частотну таблицю
 * @author Alekseenko N.
 * @date 20-dec-2020
 * @version 1.0
 */

/**
 * @file main.c
 * @brief Файл з демонстрацією роботи структури та методів
 * оперування ним.
 *
 * @author Alekseenko N.
 * @date 20-dec-2020
 * @version 1.0
 */


#include <stdio.h>
#include <stdlib.h>

/**
 * *Функція result*
 *
 * Послідовність дій:
 * - оголошеня змінних 
 *  \param n - кількість символів (повторення не вважаємо)
 *  \param p - показчик на поточний символ вхідного масиву
 *  \param k - індекс поточного символу в вихідному масиві
 *  \param l - загальна кількість символів у вхідному масиві
 *  \param c - показчик на масив символів, що не повторюються
  * \param f - показчик на масив, що містить частоту повторення символів
 * - Для кожного символу з вхідного рядка створюється запис в вихідному масиві містить сам символ і кількість його повторень, 
 * - а якщо такий запис існує, то кількість повторень збільшується на одиницю.
 * - Таблиця символів і кількість їх повторень зберігається в двох роздільних динамічних масивах.
 * - В кінці функції кількість повторень символів перетворюється в частоту.
 *  @return кількість елементів у вихідному масиві (n)
 */

int result ( char *input, char **cx, float **fx)
{
    int n = 0;
    char *p = input;
    int k;
    int l = 0;

    char *c = (char *)calloc( 1, sizeof(*c));       // создание динамического массива неповторяющихся символов

    float *f = (float *)calloc( 1, sizeof(*f));     // создание динамического массива частот повторений

    while ( *p != '\0' )                // цикл прохождения по входному массиву 
    {
        char h = *p++;
        l++;

        if ( n == 0 )                   // обработка первого символа 
        {
            k = 0;
            c[k] = h; 
            f[k] = 1;

            n++;
        }
        else                            
        {
            if ( h == c[k] )           // если текущий символ входного массива равен текущему символу выходного массива 
            {
                f[k]++;                // увеличиваем счетчик кол-ва повторений этого символа
            }
            else
            {
                int i;

                for ( i = 0; i < n ; i++ )      // в противном случае, ищем символ в выходном массиве
                {
                    if ( c[i] == h ) break;      
                }

                if ( i == n )                   // если символ не найден, то создаем в выходном массиве соответствующий элемент 
                {
                    k = n++;

                    c = (char *)realloc( c, n * sizeof(*c));
                    f = (float *)realloc( f, n * sizeof(*f));

                    c[k] = h; 
                    f[k] = 1;
                }
                else                            // если символ найден, то увеличиваем счетчик повторений
                {
                    k = i;                      // данная позиция в выходном массиве становиться текущей
                    f[k]++;                     
                }
            }  
        }    
    }

    for ( int i = 0; i < n ; i++ )              // преобразования кол-ва повторений символов в частоту
    {
        f[i] /= l;
    }

    *cx = c;
    *fx = f;

    return n;
}

/**
 * *Функція main*
 *
 * Послідовність дій:
 * - оголошеня змінних 
 *  \param input[] - вхідний масив
 *  \param c - символ, який півторюється
 *  \param f - частота появи в тексті
 *  \param n - кількість символів (повторення не вважаємо)
 *  @return успішний код повернення з програми (0)
 */

int main () 
{
    char input[] = "hi, my name is Nikita";

    char *c;
    float *f;

    int n;

    n = result( input, &c, &f);

    printf("%d\n", n );

    for ( int i = 0; i < n; i++)
    {
        printf("%c - %f\n", c[i], f[i]  );
    }
    
    return 0;
}

    






